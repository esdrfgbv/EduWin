{
  "level": 10,
  "title": "Capstone – Mixed Advanced DSA",
  "concept": "Final level that combines arrays, hash maps, prefix sums, graphs, trees, grids, and dynamic programming into classic interview-style problems.",
  "challenges": [
    {
      "id": 1,
      "title": "Maximum Subarray Sum (Kadane)",
      "description": "Given an array of N integers (can be negative), find the maximum possible sum of a non-empty contiguous subarray.",
      "inputDescription": "First line N, second line N integers.",
      "outputDescription": "One integer: maximum subarray sum.",
      "examples": [
        "Input:\n5\n-2 1 -3 4 -1\nOutput:\n4",
        "Input:\n4\n-1 -2 -3 -4\nOutput:\n-1"
      ],
      "starterCode": "// use Kadane's algorithm: keep current_sum and best_sum",
      "tests": [
        { "input": "5\n-2 1 -3 4 -1", "expected": "4" },
        { "input": "4\n-1 -2 -3 -4", "expected": "-1" }
      ]
    },
    {
      "id": 2,
      "title": "Longest Subarray with Sum K (Positive + Negative)",
      "description": "Given N and array of N integers (can be positive, zero, or negative) and an integer K, find the length of the longest subarray whose sum is exactly K. Use prefix sum + hashmap.",
      "inputDescription": "N, then N integers, then K.",
      "outputDescription": "Single integer: length of longest subarray, or 0 if none.",
      "examples": [
        "Input:\n5\n1 -1 5 -2 3\n3\nOutput:\n4",
        "Input:\n3\n1 2 3\n7\nOutput:\n0"
      ],
      "starterCode": "// prefix sum + map: store earliest index of each prefix sum",
      "tests": [
        { "input": "5\n1 -1 5 -2 3\n3", "expected": "4" },
        { "input": "3\n1 2 3\n7", "expected": "0" }
      ]
    },
    {
      "id": 3,
      "title": "Number of Islands (Grid DFS/BFS)",
      "description": "Given an N x M grid containing 0 (water) and 1 (land), count how many islands there are. An island is formed by connecting adjacent lands horizontally or vertically.",
      "inputDescription": "N M, then N lines of M values (0/1).",
      "outputDescription": "Single integer: number of islands.",
      "examples": [
        "Input:\n4 5\n1 1 0 0 0\n1 1 0 0 1\n0 0 0 1 1\n0 0 0 0 0\nOutput:\n2"
      ],
      "starterCode": "// run DFS/BFS from each unvisited 1, mark all connected as visited",
      "tests": [
        { "input": "4 5\n1 1 0 0 0\n1 1 0 0 1\n0 0 0 1 1\n0 0 0 0 0", "expected": "2" },
        { "input": "3 3\n0 0 0\n0 0 0\n0 0 0", "expected": "0" }
      ]
    },
    {
      "id": 4,
      "title": "Right View of Binary Tree",
      "description": "Given a binary tree, print the right view: the nodes visible when the tree is viewed from the right side (one node per level).",
      "inputDescription": "Binary tree given as N nodes with: value left_index right_index, -1 for null child, root at index 0.",
      "outputDescription": "Values of right view nodes from top to bottom, space-separated.",
      "examples": [
        "Input:\n5\n1 1 2\n2 -1 3\n3 -1 4\n4 -1 -1\n5 -1 -1\nOutput:\n1 3 4"
      ],
      "starterCode": "// use level order (BFS) and take last node at each level OR DFS with depth tracking",
      "tests": [
        { "input": "5\n1 1 2\n2 -1 3\n3 -1 4\n4 -1 -1\n5 -1 -1", "expected": "1 3 4" },
        { "input": "1\n10 -1 -1", "expected": "10" }
      ]
    },
    {
      "id": 5,
      "title": "LRU Cache Simulation",
      "description": "Implement an LRU (Least Recently Used) cache. You are given capacity C and Q queries. Each query is either SET key value or GET key. For GET, print the value or -1. For SET, insert/update key and if cache is full, remove least recently used key.",
      "inputDescription": "First line: C Q. Next Q lines: operations (GET k / SET k v).",
      "outputDescription": "For each GET, print the result in a new line.",
      "examples": [
        "Input:\n2 5\nSET 1 10\nSET 2 20\nGET 1\nSET 3 30\nGET 2\nOutput:\n10\n-1"
      ],
      "starterCode": "// use combination of doubly linked list + hashmap (or any structure that maintains order of use)",
      "tests": [
        { "input": "2 5\nSET 1 10\nSET 2 20\nGET 1\nSET 3 30\nGET 2", "expected": "10\n-1" },
        { "input": "1 3\nSET 5 50\nSET 6 60\nGET 5", "expected": "-1" }
      ]
    },
    {
      "id": 6,
      "title": "Dijkstra – Shortest Path in Weighted Graph",
      "description": "Given a weighted undirected graph with non-negative weights and a source S, find the shortest distance from S to all vertices using Dijkstra’s algorithm.",
      "inputDescription": "N, M, then M lines: u v w, then S. Nodes are 1..N.",
      "outputDescription": "Print N integers: dist[1] dist[2] ... dist[N] where unreachable nodes have -1.",
      "examples": [
        "Input:\n5 6\n1 2 2\n1 3 4\n2 3 1\n2 4 7\n3 5 3\n4 5 1\n1\nOutput:\n0 2 3 7 6"
      ],
      "starterCode": "// adjacency list + priority queue; initialize dist=INF, dist[S]=0",
      "tests": [
        { "input": "5 6\n1 2 2\n1 3 4\n2 3 1\n2 4 7\n3 5 3\n4 5 1\n1", "expected": "0 2 3 7 6" },
        { "input": "3 1\n2 3 5\n1", "expected": "0 -1 -1" }
      ]
    },
    {
      "id": 7,
      "title": "Valid Sudoku",
      "description": "Given a 9x9 Sudoku board, check if it is valid (not necessarily solvable). Each row, column and 3x3 subgrid must not contain duplicate digits 1-9 (0 or . can be treated as empty).",
      "inputDescription": "9 lines, each with 9 characters (digits 0-9 or .).",
      "outputDescription": "Print Yes if valid, else No.",
      "examples": [
        "Input:\n53..7....\n6..195...\n.98....6.\n8...6...3\n4..8.3..1\n7...2...6\n.6....28.\n...419..5\n....8..79\nOutput:\nYes"
      ],
      "starterCode": "// use three 9x9 boolean structures: row, col, box OR hash sets",
      "tests": [
        {
          "input": "53..7....\n6..195...\n.98....6.\n8...6...3\n4..8.3..1\n7...2...6\n.6....28.\n...419..5\n....8..79",
          "expected": "Yes"
        },
        {
          "input": "88..7....\n6..195...\n.98....6.\n8...6...3\n4..8.3..1\n7...2...6\n.6....28.\n...419..5\n....8..79",
          "expected": "No"
        }
      ]
    },
    {
      "id": 8,
      "title": "Word Search in Grid",
      "description": "Given a grid of letters and a word, determine if the word exists in the grid. The word can be constructed by sequentially adjacent cells (horizontally or vertically). Same cell cannot be used more than once.",
      "inputDescription": "N M, then N lines of M characters (no spaces), then the word.",
      "outputDescription": "Print Yes if word exists, else No.",
      "examples": [
        "Input:\n3 4\nABCE\nSFCS\nADEE\nABCCED\nOutput:\nYes"
      ],
      "starterCode": "// backtracking DFS from each cell that matches first letter, with visited[][]",
      "tests": [
        {
          "input": "3 4\nABCE\nSFCS\nADEE\nABCCED",
          "expected": "Yes"
        },
        {
          "input": "3 4\nABCE\nSFCS\nADEE\nABCB",
          "expected": "No"
        }
      ]
    },
    {
      "id": 9,
      "title": "Longest Palindromic Substring",
      "description": "Given a string S, find the length of the longest palindromic substring. Use DP or expand-around-center.",
      "inputDescription": "Single string S.",
      "outputDescription": "Single integer: length of longest palindromic substring.",
      "examples": [
        "Input:\nbabad\nOutput:\n3",
        "Input:\ncbbd\nOutput:\n2"
      ],
      "starterCode": "// for each center (i or i,i+1) expand while chars match; track best length",
      "tests": [
        { "input": "babad", "expected": "3" },
        { "input": "cbbd", "expected": "2" }
      ]
    },
    {
      "id": 10,
      "title": "All-Pairs Shortest Path (Floyd–Warshall)",
      "description": "Given N and adjacency matrix of a weighted directed graph (use a large value like 10^9 or -1 to represent no edge), compute shortest distance between every pair of vertices using Floyd–Warshall algorithm.",
      "inputDescription": "N, then N lines each with N integers (matrix). Dist[i][j] is 0 for i==j. If no edge, value will be -1.",
      "outputDescription": "Print N lines of N integers: shortest distances matrix, where unreachable pairs should be -1.",
      "examples": [
        "Input:\n4\n0 5 -1 10\n-1 0 3 -1\n-1 -1 0 1\n-1 -1 -1 0\nOutput:\n0 5 8 9\n-1 0 3 4\n-1 -1 0 1\n-1 -1 -1 0"
      ],
      "starterCode": "// initialize dist from matrix, convert -1 to INF except diagonal; run triple loop k,i,j",
      "tests": [
        {
          "input": "4\n0 5 -1 10\n-1 0 3 -1\n-1 -1 0 1\n-1 -1 -1 0",
          "expected": "0 5 8 9\n-1 0 3 4\n-1 -1 0 1\n-1 -1 -1 0"
        },
        {
          "input": "2\n0 -1\n-1 0",
          "expected": "0 -1\n-1 0"
        }
      ]
    }
  ]
}
